\hypertarget{class_velocity_i_k}{}\doxysection{Velocity\+IK Class Reference}
\label{class_velocity_i_k}\index{VelocityIK@{VelocityIK}}


Defines the Velocity Inverse \mbox{\hyperlink{class_kinematics}{Kinematics}} solver class using the Jacobian method (with one joint locked).  




{\ttfamily \#include $<$Velocity\+I\+K.\+hpp$>$}

\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_velocity_i_k_a557cbe6c1d62dcffb49d49c7e27c5bce}{Velocity\+IK}} ()
\begin{DoxyCompactList}\small\item\em Construct a new Velocity IK object. \end{DoxyCompactList}\item 
nc\+::\+Nd\+Array$<$ double $>$ \mbox{\hyperlink{class_velocity_i_k_adbbe686948ac7e77d00249ca6863bc75}{cartesian\+\_\+velocity}} (double $\ast$theta)
\begin{DoxyCompactList}\small\item\em Defines the cartesian velocity trajectory of the robot\textquotesingle{}s end-\/effector, assuming angular speed to be zero. \end{DoxyCompactList}\item 
std\+::vector$<$ double $>$ \mbox{\hyperlink{class_velocity_i_k_ae58a64243d86eeb8c3721d483789ead5}{update\+\_\+joint\+\_\+angles}} (double $\ast$dt, std\+::vector$<$ double $>$ $\ast$present\+\_\+joint\+\_\+angle, std\+::vector$<$ double $>$ $\ast$joint\+\_\+angle\+\_\+dot)
\begin{DoxyCompactList}\small\item\em Performs numerical integration of the joint speed to obtain joint position for a small time-\/step using the update equation, q\+\_\+next = q\+\_\+curr + q\+\_\+dot $\ast$ dt. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_velocity_i_k_ae48fa2a2042a47a2c78170044573eb28}{compute\+\_\+jacobian}} (std\+::vector$<$ double $>$ $\ast$joint\+\_\+angle)
\begin{DoxyCompactList}\small\item\em Computes the Jacobian matrix of the robot. \end{DoxyCompactList}\item 
nc\+::\+Nd\+Array$<$ double $>$ \mbox{\hyperlink{class_velocity_i_k_a07075ab3433d75bfe09d05a3dbd57552}{get\+\_\+jacobian}} ()
\begin{DoxyCompactList}\small\item\em Accessor function to get the Jacobian matrix of the robot. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Defines the Velocity Inverse \mbox{\hyperlink{class_kinematics}{Kinematics}} solver class using the Jacobian method (with one joint locked). 



Definition at line 21 of file Velocity\+I\+K.\+hpp.



\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_velocity_i_k_a557cbe6c1d62dcffb49d49c7e27c5bce}\label{class_velocity_i_k_a557cbe6c1d62dcffb49d49c7e27c5bce}} 
\index{VelocityIK@{VelocityIK}!VelocityIK@{VelocityIK}}
\index{VelocityIK@{VelocityIK}!VelocityIK@{VelocityIK}}
\doxysubsubsection{\texorpdfstring{VelocityIK()}{VelocityIK()}}
{\footnotesize\ttfamily Velocity\+I\+K\+::\+Velocity\+IK (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Construct a new Velocity IK object. 



Definition at line 24 of file Velocity\+I\+K.\+cpp.



\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_velocity_i_k_adbbe686948ac7e77d00249ca6863bc75}\label{class_velocity_i_k_adbbe686948ac7e77d00249ca6863bc75}} 
\index{VelocityIK@{VelocityIK}!cartesian\_velocity@{cartesian\_velocity}}
\index{cartesian\_velocity@{cartesian\_velocity}!VelocityIK@{VelocityIK}}
\doxysubsubsection{\texorpdfstring{cartesian\_velocity()}{cartesian\_velocity()}}
{\footnotesize\ttfamily nc\+::\+Nd\+Array$<$ double $>$ Velocity\+I\+K\+::cartesian\+\_\+velocity (\begin{DoxyParamCaption}\item[{double $\ast$}]{theta }\end{DoxyParamCaption})}



Defines the cartesian velocity trajectory of the robot\textquotesingle{}s end-\/effector, assuming angular speed to be zero. 


\begin{DoxyParams}{Parameters}
{\em theta} & Cylindrical co-\/ordinate system angle for the trajectory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
nc\+::\+Nd\+Array$<$double$>$ Cartesian velocity of the robot\textquotesingle{}s end effector. 
\end{DoxyReturn}


Definition at line 27 of file Velocity\+I\+K.\+cpp.

\mbox{\Hypertarget{class_velocity_i_k_ae48fa2a2042a47a2c78170044573eb28}\label{class_velocity_i_k_ae48fa2a2042a47a2c78170044573eb28}} 
\index{VelocityIK@{VelocityIK}!compute\_jacobian@{compute\_jacobian}}
\index{compute\_jacobian@{compute\_jacobian}!VelocityIK@{VelocityIK}}
\doxysubsubsection{\texorpdfstring{compute\_jacobian()}{compute\_jacobian()}}
{\footnotesize\ttfamily bool Velocity\+I\+K\+::compute\+\_\+jacobian (\begin{DoxyParamCaption}\item[{std\+::vector$<$ double $>$ $\ast$}]{joint\+\_\+angle }\end{DoxyParamCaption})}



Computes the Jacobian matrix of the robot. 


\begin{DoxyParams}{Parameters}
{\em joint\+\_\+angle} & Current joint angles of the robot \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true If the Jacobian exists and is computed. 

false If the Jacobian is singular. 
\end{DoxyReturn}


Definition at line 53 of file Velocity\+I\+K.\+cpp.

\mbox{\Hypertarget{class_velocity_i_k_a07075ab3433d75bfe09d05a3dbd57552}\label{class_velocity_i_k_a07075ab3433d75bfe09d05a3dbd57552}} 
\index{VelocityIK@{VelocityIK}!get\_jacobian@{get\_jacobian}}
\index{get\_jacobian@{get\_jacobian}!VelocityIK@{VelocityIK}}
\doxysubsubsection{\texorpdfstring{get\_jacobian()}{get\_jacobian()}}
{\footnotesize\ttfamily nc\+::\+Nd\+Array$<$ double $>$ Velocity\+I\+K\+::get\+\_\+jacobian (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Accessor function to get the Jacobian matrix of the robot. 

\begin{DoxyReturn}{Returns}
nc\+::\+Nd\+Array$<$double$>$ Jacobian matrix (6x6) 
\end{DoxyReturn}


Definition at line 177 of file Velocity\+I\+K.\+cpp.

\mbox{\Hypertarget{class_velocity_i_k_ae58a64243d86eeb8c3721d483789ead5}\label{class_velocity_i_k_ae58a64243d86eeb8c3721d483789ead5}} 
\index{VelocityIK@{VelocityIK}!update\_joint\_angles@{update\_joint\_angles}}
\index{update\_joint\_angles@{update\_joint\_angles}!VelocityIK@{VelocityIK}}
\doxysubsubsection{\texorpdfstring{update\_joint\_angles()}{update\_joint\_angles()}}
{\footnotesize\ttfamily std\+::vector$<$ double $>$ Velocity\+I\+K\+::update\+\_\+joint\+\_\+angles (\begin{DoxyParamCaption}\item[{double $\ast$}]{dt,  }\item[{std\+::vector$<$ double $>$ $\ast$}]{present\+\_\+joint\+\_\+angle,  }\item[{std\+::vector$<$ double $>$ $\ast$}]{joint\+\_\+angle\+\_\+dot }\end{DoxyParamCaption})}



Performs numerical integration of the joint speed to obtain joint position for a small time-\/step using the update equation, q\+\_\+next = q\+\_\+curr + q\+\_\+dot $\ast$ dt. 


\begin{DoxyParams}{Parameters}
{\em dt} & Time-\/step (sec) \\
\hline
{\em present\+\_\+joint\+\_\+angle} & Current value of joint angle (rad) \\
\hline
{\em joint\+\_\+angle\+\_\+dot} & Joint angular speed from inverse kinematics (rad/s) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$double$>$ Next value of joint angle (rad) 
\end{DoxyReturn}


Definition at line 37 of file Velocity\+I\+K.\+cpp.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
/media/okritvik/\+D\+A\+T\+A/\+U\+M\+D/\+Course\+\_\+\+Work/\+E\+N\+P\+M808\+X/\+Assignments/\+Acme-\/\+Manipulator-\/\+I\+K-\/\+Solver/include/\mbox{\hyperlink{_velocity_i_k_8hpp}{Velocity\+I\+K.\+hpp}}\item 
/media/okritvik/\+D\+A\+T\+A/\+U\+M\+D/\+Course\+\_\+\+Work/\+E\+N\+P\+M808\+X/\+Assignments/\+Acme-\/\+Manipulator-\/\+I\+K-\/\+Solver/app/\mbox{\hyperlink{_velocity_i_k_8cpp}{Velocity\+I\+K.\+cpp}}\end{DoxyCompactItemize}
